一、函数回顾与后置返回类型
    函数定义中，形参如果在函数体内用不到的话，则可以不给形参变量名字，只给其类型。
	void fun(int a, int);
	函数声明时，可以只有形参类型，没有形参名。
	把函数返回类型放到函数名字之前，这种写法，叫前置返回类型。
	c++11中，后置返回类型。就是在函数声明和定义中，把返回类型写在参数列表之后。
	    前面放auto，表示函数返回类型放到参数列表之后，而放在参数列表之后的返回类型是通过-> 开始的。
		auto fun(int a, int b) -> void;  //函数声明
		auto fun(int a, int b) -> void //函数定义
		{
			return;
		}

二、内联函数：在函数定义前增加了关键字inline，导致该函数变成内联函数。
    函数体很小，调用有很频繁的这种函数。咱们引入inline(内联函数)
	(1)inline影响编译器，在编译阶段对inline这种函数进行处理，系统尝试将调用该函数的动作替换为函数本体。通过这种方式来提升性能。
	(2)inline 只是我们开发者对编译器的建议，编译器可以尝试去做，也可以不去做，这取决于编译器的诊断功能，也就是说，决定权在编译器。
	(3)内联函数的定义放在头文件中。这样需要用到这个内联函数的.cpp文件都能够通过#include 把这个内联函数的源代码#include进来
	   以便找到这个函数的本体源代码并尝试将该函数的调用替换为函数体内的语句。
	 
	优缺点：
	代码膨胀的问题;所以内联函数函数体尽量要小。
	注意:各种编译器对inline的处理各不相同。inline函数尽量简单，代码尽可能少。循环，分支，递归调用
	     尽量不要出现在inline函数中。否则的话，编译器很可能会因为你写的这些代码的原因拒绝让这个函数称为一个inline函数。
	
	constexpr函数  可以看成更严格的一种内联函数。
	constexpr int mf()
	{
		//写的特别简单
	}
	#define宏展开也类似于inline
	
三、函数杂合用法总结
    (1)函数返回类型为void，表示函数不返回任何类型。但是我们可以调用一个返回类型是void的函数
	让它作为另一个void的函数的返回值。
	void funA()
	{
	}
    void funB()
	{
		return funA();  //这种写法是可以的
		return;   //这种也是可以的
	}
	(2)函数返回指针和返回引用的情况
	int *myfunc()
	{
		int tmpvalue = 9;
		return &tmpvalue;   //这不可以，因为函数执行完毕后，tmpvalue这段内存被系统回收，你不能够再使用
	}
	int *p = myfunc();
	*p = 6;
	
	int &myfunc()
	{
		int tmpvalue = 9;
		cout << &tmpvalue << endl;
		return tmpvalue;   //又是一个巨大隐患
	}
	int &k = myfunc();
	cout << &k << endl;
	k = 10;       //你往一个不属于你的地址写了数字。
	
	int k = myfunc();
	cout << &k << endl;
	k = 10;  //这种写法是安全的。
	
	(3)没有形参可以保持形参列表为空(),或者int myfunc(void)
	(4)如果一个函数我们如果不调用的话，则该函数可以只有声明部分，没有定义部分。
	(5)普通函数，定义只能定义一次(定义放在.cpp文件中)，声明可以声明多次。一般函数定义.cpp文件会#include自己的函数声明文件(.h)
	(6)void func(int &ta, int &tb),在C++中，更习惯用引用类型的形参来取代指针类型的形参。提倡在C++中，多使用引用类型的形参
	(7)C++中，函数允许同名，但是形参列表的参数类型或者数量应该有明显的区别。

四、const char *, char const *, char * const 三者的区别
    (1)const char *p;
	char str[] = "I Love China!";
	const char *p; //p指向的东西不能通过p来修改(p所指向的目标，那个目标中的内容不能通过p来改变)；
	p = str;
	//*p = 'Y';  //语法错误
	p++;
	str[0] = 'Y'; //这是OK的
	(2)char const * 等价于 const char *p
	(3)char * const
	char str[] = "I Love China!";
	char * const p = str; //定义的时候必须初始化
	                      //p一旦指向了一个东西之后，就不可以再指向其他东西了。
	//p++; //不可以，p一旦指向了一个东西之后，就不可以再指向其他东西了。
	*p = 'Y'; //但可以修改p指向的目标中的内容。
	(4)const char * const p = str;
	char const * const p = str; //p的指向也不能变。p指向的内容也不能通过p来改变。
	例：
	int i = 100;
	const int &a = i; //代表a的内容不能通过a自己来修改。
	i = 100；
	//a = 500 //不合法
	
五、函数形参中带const
	把形参写成const的形式有很多好处
	(1)可以防止你无意中修改了形参值导致实参值被无意修改。
	(2)实参类型可以更灵活。
	
	