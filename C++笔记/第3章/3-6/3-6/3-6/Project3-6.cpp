// 3-6.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "Time.h"


int main()
{
	//一、重载运算符
	// == > >= <= != ++ -- += -= + -
	//两个对象真的不能进行==比较吗？是可以比较的，我们需要“重载 == 运算符”，
	//说白了，我们要写一个成员函数，这个成员函数名就叫 “operator==”，这个成员函数里边我们就要写一些比较逻辑。

	//正式总结一下：
	//重载运算符，本质上是一个函数，整个函数的正式名字：operator关键字 接 运算符
	//既然重载运算符本质上是一个函数，那么会有返回类型和参数列表。
	//有一些 运算符，如果我们不自己写该运算符的重载，那么系统就会自动给我们生成一个。比如赋值运算符的重载。

	//二、拷贝赋值运算符
	Time myTime; //调用了Time::Time()构造函数
	Time myTime2 = myTime; //调用了Time::Time(Time &tmptime, int a) 拷贝运算符
	Time myTime3 = { myTime }; ////调用了Time::Time(Time &tmptime, int a) 拷贝运算符

	
	Time myTime4; //调用了Time::Time()构造函数
	//调用了Time & Time::operator=(const Time&)赋值运算符重载
	myTime4 = myTime3; //这个是赋值运算符， 既没调用构造函数，也没调用拷贝构造函数
	                   //系统会调用一个拷贝赋值运算符
	//我们可以自己重载赋值运算符，如果我们自己不重载，编译器也会为我们生成一个(编译器格外喜欢赋值运算符)
	//编译器生成的赋值运算符重载比较粗糙。一般就是将非static成员赋值给赋值运算符左侧的对象的对应成员中去。
	//如果你这个成员是个类对象，可能还会调用这个类的拷贝赋值运算符
	//为了精确控制Time类的赋值动作，我们往往会自己来重载赋值运算符
	//重载赋值运算符:有返回类型和参数列表，这里的参数就表示运算符的运算对象
	//myTime4就是this对象，myTime3就是=里边的参数

	//三、析构函数：相对于构造函数，对象在销毁的时候，会自动调用析构函数。
	//如果我们自己不写自己的析构函数，编译器也会生成一个默认的析构函数。默认析构函数的函数体为空，表示默认的析构函数没干什么事儿
	//析构函数里new， delete
	//析构函数也是类的成员函数，他的名字是由~接类名构成，没有返回值，不接受任何参数，不能被重载，所以一个给定的类，只有唯一一个析构函数
	//函数重载：。。。

	//构造函数的成员初始化:干了两件事，函数体之前和函数体之中
	//析构函数的成员销毁：干了两件事，函数体， 函数体之后
	//成员变量的初始化和销毁时机问题：先定义的先初始化，销毁时先定义的后销毁

	//new 和 delete 对象
	Time *pmytime = new Time; //系统自动调用不带参数的构造函数
	Time *pmytime2 = new Time();  //系统自动调用不带参数的构造函数
	//但是，大家务必要注意，我们new出来的对象，必须要自己释放，否则就会造成内存泄漏
	//在程序停止运行之前的某个时刻，你一定要用
	delete pmytime;
	delete pmytime2;
	//你什么时候delete，系统就会在什么时候调用类的析构函数
	
	return 0;
}

