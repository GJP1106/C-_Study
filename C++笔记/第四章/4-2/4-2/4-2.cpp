// 4-2.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <iostream>
#include "myvector.h"
#include "myarray.h"
using namespace std;

int main()
{
	//一、概述：用类模板来实例化一个特定的类。
	//编译器不能为类模板推断模板参数类型，所以为了使用类模板，我们必须在模板名后边用<>来提供额外的信息，
	//这些信息其实就是对应着模板参数里边的这些参数
	//vector<int>：实现同一套代码，可以 应付 不能的数据类型，这样就显得精简多了

	//二、类模板定义
	/*template<typename 形参名1， typename 形参名2,...typename 形参名n>
	class 类名
	{

	};*/
	//vector, myvector
	//实例化类模板的时候，必须要有类的全部信息，包括类模板中成员函数的函数体；
	//创建一个myvector.h

	myvector<int> tmpvec;  //这个时候，编译器就给咱们生成了一个具体的类了
	myvector<double> tmpvec1;
	myvector<string> tmpvec2;
	//myvector是类模板名，它不是一个类名，类模板是 用来实例化类(类型)用的。
	//所以myvector<double>,myvector<string>才是类型名(实例化了的类型)。
	//所以，一个实例化了的类型，总会用<>包含着模板参数



	//三、类模板的成员函数
	//类模板成员函数，可以写在类模板定义中{}；那么这种写在类模板定义中的成员函数会被隐式声明为inline函数
	//类模板一旦被实例化之后，那么这个模板的每个实例都会有自己版本的成员函数。
	  //所以，类模板的成员函数具有和这个类模板相同的模板参数(这句话的核心意思：类模板的成员函数是有模板参数的)；
	//如果你要把类模板成员函数的定义(函数体)写在类模板定义的外边，那么这个成员函数的模板参数就体现出来了。

	//定义在类模板之外的成员函数必须以关键字template开始，后边接类模板参数列表
	  //同时，在类名后边要用<>把模板参数列表里边的所有模板参数名列出来，如果是多个模板参数，用逗号分隔

	//一个类模板虽然可能有很多成员函数，但是，当你实例化模板之后，如果你后续没有使用到某个成员函数，则这个成员函数不会被实例化。
	//说白了，就是一个实例化的模板，它的成员函数只有在使用的时候才会被实例化。

	//四、模板类名字的使用

	//五、非类型模板参数
	myarray<int, 100> tmparray;
	tmparray.myfunc();  //100
	myarray<int> tmparray1;
	tmparray1.myfunc();  //10

	//非类型模板参数有一些限制的；
	//(1)浮点型不能做非类型模板参数。比如float、double
	//(2)类类型一般也不允许做非类型模板参数




	return 0;
}

